package com.codingshuttle.jpaTutorial.jpaTuts.entities;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.math.BigDecimal;
import java.time.LocalDateTime;


@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Entity
@Table(
        name="product_table",
        uniqueConstraints = {
                @UniqueConstraint(name = "sku_unique",columnNames = {"sku"}),   //we want "sku" to be unique and defining a constraint
                @UniqueConstraint(name= "title_price_unique",columnNames = {"title_x","price"})
        },
        indexes = {
                @Index(name = "sku_index",columnList = "sku")
        }
)

public class ProductEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @Column(nullable = false,length = 20) //"sku" wont be null. Hibernate makes sures that sql query that was generated to create this Product Entity makes the "sku" field as not nullable (you cannot give null to "sku" field in database)
    private String sku;//another kind of id
    @Column(name = "title_x")
    private String title;
    private BigDecimal price;
    private Integer quantity;

    @CreationTimestamp
    private LocalDateTime createdAt;
    @UpdateTimestamp
    private LocalDateTime updatedAt;
}



/*
see UniqueConstraint on title and price, it means

Cannot have 2 items whose title and price are same
Ex:
parle 20
parle 50
Accepted âœ…

parle 20
parle 20
Not accepted  âŒ



Indexes are used to enhance our get queries.
Indexes define the index table with help of algos like btrees,hashtable and will create a short db to gather the data fastly.
Index on "Id" is autogenerated   (we have written on top of "Id")
We can define Index on various columns.


Say we are querying on basis of "sku" lot of times, we want to create an index on "sku"

*/


//explanation from chatgpt. LONG PARA BELOW. FOR QUICK RECAP JUST READ FROM LINE 545-634 enough
/*
when i run the spring boot application with just product entity, and i configured mysql , in console it is giving hibernate sql output as below

Hibernate:
    create table product_table (
        id bigint not null auto_increment,
        created_at datetime(6),
        price decimal(38,2),
        quantity integer,
        sku varchar(20) not null,
        title_x varchar(255),
        updated_at datetime(6),
        primary key (id)
    ) engine=InnoDB
Hibernate:
    create index sku_index
       on product_table (sku)
Hibernate:
    alter table product_table
       drop index sku_unique
Hibernate:
    alter table product_table
       add constraint sku_unique unique (sku)
Hibernate:
    alter table product_table
       drop index title_price_unique
Hibernate:
    alter table product_table
       add constraint title_price_unique unique (title_x, price)



1ï¸âƒ£ What is happening when you run the app with ONLY this entity?

You have:
@Entity present
MySQL configured
spring.jpa.hibernate.ddl-auto=update (implicitly or explicitly)

â¡ï¸ Hibernate scans entities â†’ compares entity metadata with DB â†’ syncs schema
This process is called schema update.


2ï¸âƒ£ Step-by-step explanation of the SQL you see
âœ… Step 1: Hibernate creates the table
create table product_table (
    id bigint not null auto_increment,
    created_at datetime(6),
    price decimal(38,2),
    quantity integer,
    sku varchar(20) not null,
    title_x varchar(255),
    updated_at datetime(6),
    primary key (id)
) engine=InnoDB


Why no unique constraints here yet?
Because:
Hibernate creates table first
Constraints & indexes are added after, in separate steps
This is normal behavior.


âœ… Step 2: Hibernate creates your explicit index
create index sku_index on product_table (sku)

This comes from:
indexes = {
    @Index(name = "sku_index", columnList = "sku")
}

âœ”ï¸ Straightforward.




3ï¸âƒ£ Now the confusing part: â€œDROP INDEXâ€ ğŸ¤¯
â“ Why is Hibernate dropping indexes it just created?

Example:
alter table product_table drop index sku_unique
alter table product_table add constraint sku_unique unique (sku)

ğŸ”´ IMPORTANT CONCEPT (MySQL-specific)

ğŸ‘‰ In MySQL, a UNIQUE constraint is implemented as a UNIQUE INDEX

There is no separate object called:
â€œunique constraintâ€
â€œunique indexâ€

They are the same thing internally.

ğŸ” What Hibernate is doing internally
Hibernate wants:
@UniqueConstraint(name = "sku_unique", columnNames = {"sku"})

But MySQL:
Automatically creates a unique index
Names may not match Hibernateâ€™s expected name

So Hibernate does this:
1ï¸âƒ£ Drop any existing index with that name (defensive step)
drop index sku_unique

Even if:
It doesnâ€™t exist
Or MySQL created one implicitly

2ï¸âƒ£ Re-create it explicitly with correct definition
add constraint sku_unique unique (sku)
âœ”ï¸ This guarantees schema consistency



Same logic for composite unique constraint
drop index title_price_unique
add constraint title_price_unique unique (title_x, price)

From:
@UniqueConstraint(
   name="title_price_unique",
   columnNames={"title_x","price"}
)


4ï¸âƒ£ Why does Hibernate not create unique constraints directly in CREATE TABLE?
Because:
Different DBs behave differently (MySQL, PostgreSQL, Oracle)
Hibernate uses a portable strategy
Constraints are added after table creation for safety





5ï¸âƒ£ Now your conceptual questions (VERY IMPORTANT)
â¤ What are indexes?
Simple definition

An index is a separate data structure that helps the database find rows faster, without scanning the entire table.

Without index (full table scan)
SELECT * FROM product_table WHERE sku='ABC123';


DB does:
Check row 1
Check row 2
Check row 3
â€¦
Check all rows ğŸ˜µ
Time: O(n)

With index on sku
DB:
Looks at index
Finds row address immediately
Jumps directly to that row

Time: O(log n)

â¤ How indexes work internally (simplified)
Most common structure: B-Tree
            [SKU M]
           /        \
     [SKU A-F]   [SKU N-Z]
        |             |
   row pointers   row pointers


Index stores:
  Column value (sku)
  Pointer to actual row (disk address)
Tree stays sorted
Fast search, insert, delete


Internally:
Operation	Without Index	With Index
SELECT WHERE	slow	fast
INSERT	fast	slightly slower
UPDATE	fast	slower
DELETE	fast	slower

âš ï¸ Indexes speed up reads, slow down writes

â¤ Why not index every column?
Because:
Index consumes memory
Insert/update cost increases
Too many indexes â†’ performance degradation
ğŸ‘‰ Index only frequently queried columns




6ï¸âƒ£ â€œIndex on id is autogeneratedâ€ â€“ what does this mean?
You wrote:
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;


Hibernate generates:
primary key (id)

In MySQL:
ğŸ‘‰ PRIMARY KEY automatically creates a UNIQUE INDEX

So internally MySQL does:
    Primary Key Constraint âœ…
    Unique Index on id âœ…

Even if you donâ€™t explicitly define it.

Thatâ€™s why:
â€œIndex on id is autogeneratedâ€
You never wrote @Index â€” MySQL did it implicitly.


7ï¸âƒ£ Summary (read this twice)
âœ” Prevent confusion

Unique constraint = unique index (in MySQL)
Hibernate drops & re-adds indexes to ensure correctness
ddl-auto=update is schema reconciliation, not blind creation
Primary key always has an index
Indexes speed reads, slow writes






1ï¸âƒ£ First, the clean mental model (IMPORTANT)
	Constraint = rule
	Index = data structure
They are NOT the same thing, but sometimes one is implemented using the other.

2ï¸âƒ£ What is a CONSTRAINT?
A constraint is a rule enforced by the database to protect data correctness.
Constraints answer:
	âŒ â€œIs this data allowed or not?â€
They do NOT care about performance.

Common constraints
ğŸ”¹ PRIMARY KEY
Rules:
	â€¢ Cannot be NULL
	â€¢ Must be UNIQUE
	â€¢ Identifies a row

PRIMARY KEY (id)

ğŸ”¹ UNIQUE
Rules:
	â€¢ No two rows can have the same value(s)

UNIQUE (sku)
UNIQUE (title, price)

ğŸ”¹ NOT NULL
Rules:
	â€¢ Value must exist

sku VARCHAR(20) NOT NULL

ğŸ”¹ FOREIGN KEY
Rules:
	â€¢ Value must exist in another table

FOREIGN KEY (order_id) REFERENCES orders(id)

ğŸ”¹ CHECK
Rules:
	â€¢ Value must satisfy condition

CHECK (price > 0)

Key takeaway about constraints
	â€¢ They validate data
	â€¢ They can reject INSERT / UPDATE
	â€¢ They do not help searching

3ï¸âƒ£ What is an INDEX?
An index is a performance optimization structure.
Indexes answer:
	âš¡ â€œHow fast can I find the data?â€
Indexes do not validate data correctness.

Example

CREATE INDEX sku_index ON product_table(sku);
What this does:
	â€¢ Creates a B-Tree
	â€¢ Stores (sku â†’ row_address)
	â€¢ Speeds up SELECT WHERE sku = ?

Index properties
	â€¢ Improves SELECT
	â€¢ Slows INSERT / UPDATE / DELETE
	â€¢ Uses extra memory

4ï¸âƒ£ So why do people mix CONSTRAINT and INDEX?
Because some constraints NEED an index to be enforced efficiently.

5ï¸âƒ£ The BIG overlap (this is the key confusion)
UNIQUE constraint needs an index
How can the DB check:
	â€œIs this value already present?â€
Without an index:
	â€¢ DB must scan entire table âŒ
	â€¢ Too slow âŒ
So databases do this:
	UNIQUE constraint is implemented USING a UNIQUE INDEX

Same for PRIMARY KEY
PRIMARY KEY rules:
	â€¢ Unique
	â€¢ Not null
So DB does:
	â€¢ PRIMARY KEY constraint
	â€¢ UNIQUE index automatically

6ï¸âƒ£ MySQL-specific behavior (IMPORTANT)
In MySQL:
Concept	Separate object?
UNIQUE constraint	âŒ
UNIQUE index	âœ…
PRIMARY KEY	Constraint + index
INDEX	Index only
ğŸ‘‰ MySQL does not store UNIQUE constraints separately.
ğŸ‘‰ It stores them as unique indexes.
Thatâ€™s why Hibernate SQL shows:

drop index sku_unique
add constraint sku_unique unique (sku)
Internally MySQL:
	â€¢ Drops index
	â€¢ Creates unique index again
Hibernate speaks standard SQL
MySQL executes index operations

7ï¸âƒ£ Visual analogy (remember this)
ğŸ› Constraint = Law
	â€œOnly one person can have this Aadhaar numberâ€
ğŸ—‚ Index = Filing system
	â€œHere is a sorted list to quickly check Aadhaar numbersâ€
Law â‰  filing system
But law uses filing system to enforce itself efficiently.


9ï¸âƒ£ Can index exist without constraint?
âœ” YES

CREATE INDEX sku_index ON product_table(sku);
	â€¢ Duplicate values allowed
	â€¢ Fast search
	â€¢ No data validation

ğŸ”Ÿ Can constraint exist without index?
In theory:
âœ” YES (logical rule)
In practice:
âŒ NO (for UNIQUE / PRIMARY KEY)
DB automatically creates index to enforce it.



1ï¸âƒ£2ï¸âƒ£ Why Hibernate drops & recreates indexes
Hibernate wants:
	â€¢ Constraint name
	â€¢ Column order
	â€¢ DB consistency
So it:
	1. Drops old index
	2. Recreates as constraint
	3. MySQL stores it again as index
This is schema synchronization, not duplication.


Why Hibernate drops & recreates indexes (deep but clear)
Hibernate is doing schema reconciliation:
	â€œWhat I want the database to look like
	vs
	what the database currently looks likeâ€
If there is any mismatch, Hibernate fixes it.

1ï¸âƒ£ â€œConstraint nameâ€ â€” why Hibernate cares
Your entity says:

@UniqueConstraint(
   name = "sku_unique",
   columnNames = {"sku"}
)
This is metadata, not just SQL.
Hibernate internally stores:

Constraint:
- type: UNIQUE
- name: sku_unique
- columns: [sku]

What MySQL might have
When MySQL creates a unique index automatically, it might:
	â€¢ Use a different internal name
	â€¢ Or treat it as an index, not a constraint
	â€¢ Or reuse an old index created earlier
Example:

UNIQUE KEY sku (sku)
Hibernate sees:
âŒ Name mismatch
âŒ Type mismatch (index vs constraint)
So Hibernate thinks:
	â€œThis is NOT the same constraint I asked for.â€
â¡ï¸ Drop & recreate

2ï¸âƒ£ â€œColumn orderâ€ â€” why order matters
Your composite constraint:

@UniqueConstraint(
   name = "title_price_unique",
   columnNames = {"title_x", "price"}
)
Hibernate expects:

UNIQUE (title_x, price)

What if DB has:

UNIQUE (price, title_x)
Logically:
	â€¢ Uniqueness rule is the same âŒ (for constraint)
	â€¢ Index behavior is NOT the same âŒ (for performance)
Example:

WHERE title_x = 'parle' AND price = 20   -- fast
WHERE price = 20 AND title_x = 'parle'   -- slower
So Hibernate checks:
	â€¢ Column list
	â€¢ Column order
If order differs â†’ mismatch â†’ drop & recreate.

3ï¸âƒ£ â€œDB consistencyâ€ â€” Hibernateâ€™s paranoia (for good reason)
Hibernate supports:
	â€¢ MySQL
	â€¢ PostgreSQL
	â€¢ Oracle
	â€¢ SQL Server
	â€¢ H2
Each DB:
	â€¢ Names constraints differently
	â€¢ Handles indexes differently
	â€¢ Auto-creates things implicitly
Hibernate follows this rule:
	â€œIf I cannot be 100% sure, I recreate.â€
So instead of guessing, Hibernate:
	1. Drops what exists
	2. Creates exactly what entity metadata describes
This avoids:
	â€¢ Silent bugs
	â€¢ Half-correct schemas
	â€¢ Production disasters





!!!!!!!!MOST IMPORTANT!!!!!!:

Step-by-step: YOUR exact SQL sequence
Letâ€™s replay your console output like a movie ğŸ¬

ğŸ¬ Scene 1: Table creation

create table product_table ( ... )
âœ”ï¸ Table exists
âŒ No constraints yet

ğŸ¬ Scene 2: Index from @Index

create index sku_index on product_table (sku)
âœ”ï¸ Performance index created

ğŸ¬ Scene 3: Unique constraint reconciliation
Hibernate checks DB:
	â€œDo I already have UNIQUE constraint named sku_unique?â€
DB answers:
	â€œI have an index, not a constraint.â€
Hibernate says:
	â€œNot acceptable.â€

ğŸ¬ Scene 4: Defensive cleanup

alter table product_table drop index sku_unique
Even if:
	â€¢ It doesnâ€™t exist
	â€¢ Or exists with different definition
Hibernate is resetting state.

ğŸ¬ Scene 5: Correct creation

alter table product_table add constraint sku_unique unique (sku)
MySQL internally:
	â€¢ Creates a unique index
	â€¢ But now matches Hibernateâ€™s metadata

ğŸ¬ Same logic repeats for composite constraint

drop index title_price_unique
add constraint title_price_unique unique (title_x, price)

Very important misconception to kill âŒ
	â€œHibernate created index â†’ why drop it?â€
Because:
	â€¢ That index was not created for uniqueness
	â€¢ It was created for query performance
	â€¢ Unique constraint requires guaranteed uniqueness rule
Different purpose â†’ different metadata â†’ rebuild.



âœ… Your understanding â€” verified & refined

âœ”ï¸ Correct (with precision)
	â€¢ PRIMARY KEY = NOT NULL + UNIQUE (rule-wise)
	â€¢ To enforce UNIQUE efficiently, the database creates an index
	â€¢ Therefore:
	âœ… Primary Key is ALWAYS backed by an index
In MySQL (and most DBs):
	â€¢ PRIMARY KEY â†’ unique index automatically created
	â€¢ You cannot have a primary key without an index
âœ”ï¸ Your reasoning is solid.

ğŸ”¹ Your statement:
	Though unique constraint and unique index are same, to match the metadata, it drops existing index and creates unique constraint which again internally uses unique index only.
âœ”ï¸ Correct (minor wording fix)
Better wording:
	Though unique constraint and unique index are different concepts,
	MySQL implements a unique constraint USING a unique index.
	Hibernate drops the existing index if it doesnâ€™t match metadata and recreates the unique constraint,
	which MySQL again stores internally as a unique index.

âš ï¸ One tiny clarification (important but small)
âŒ â€œunique constraint and unique index are sameâ€ â€” not conceptually
âœ… They are implemented the same way in MySQL
Correct mental model:
Layer	Meaning
SQL / JPA	UNIQUE constraint = rule
Database engine	Unique index = mechanism
MySQL	Stores constraint as index
Hibernate lives at rule level
MySQL executes at mechanism level

ğŸ§  Final corrected one-liner (memorize this)
	Primary key is always indexed because it enforces uniqueness.
	Unique constraints are enforced using unique indexes.
	Hibernate recreates them to match metadata, and MySQL stores them again as indexes.



DOUBT2:
Instead of constraint can i use validation somehow and make sure there can by only one "sku"?

Short answer (clear & honest)
	âŒ No â€” validation alone is NOT sufficient to guarantee only one sku.
You can use validation, but you MUST still use a database constraint.
Validation â‰  Guarantee.

Why this doubt comes naturally
Youâ€™re thinking:
	â€œIf I check in code before saving,
	why do I need a DB constraint?â€
That sounds reasonable â€” until concurrency enters the picture.
Letâ€™s break it.

1ï¸âƒ£ What â€œvalidationâ€ means in practice
Example validation in Spring:

if (productRepository.existsBySku(sku)) {
    throw new RuntimeException("SKU already exists");
}
productRepository.save(product);
Or with Bean Validation:

@NotNull
private String sku;
Or even a custom validator.

What validation does well
âœ”ï¸ Gives nice error messages
âœ”ï¸ Catches issues early
âœ”ï¸ Improves user experience

What validation CANNOT guarantee
âŒ Uniqueness under concurrency
âŒ Protection from multiple app instances
âŒ Protection from direct DB access
âŒ Absolute data integrity

2ï¸âƒ£ The fatal problem: race conditions ğŸ’¥
Scenario (VERY REAL)
Two users hit your API at the same time:

Thread A                   Thread B
---------                  ---------
existsBySku("ABC") â†’ false
                            existsBySku("ABC") â†’ false
save("ABC")
                            save("ABC")
Result:

ABC
ABC   âŒ duplicate
Your validation passed.
Your data is now corrupted.

Why this happens
Because:
	â€¢ Validation runs outside the database
	â€¢ Database is the only shared authority
	â€¢ App-level checks are not atomic

3ï¸âƒ£ Database constraint = final authority
When you define:

UNIQUE (sku)
The database guarantees:
	â€œNo matter WHO inserts
	No matter HOW
	No matter WHEN
	there will be only ONE sku.â€
Even if:
	â€¢ 100 concurrent requests
	â€¢ Multiple app servers
	â€¢ Manual SQL inserts
âœ”ï¸ Absolute guarantee.

4ï¸âƒ£ Correct architecture (this is the key)
âœ… Use BOTH
Layer	Responsibility
Validation	User-friendly feedback
Constraint	Data integrity guarantee

Typical professional setup
Entity

@Column(nullable = false, unique = true)
private String sku;
Service

if (repo.existsBySku(sku)) {
    throw new IllegalArgumentException("SKU already exists");
}
DB

UNIQUE (sku)

5ï¸âƒ£ What happens when both are used?
	1. Validation catches most cases early
	2. Constraint catches edge cases (race conditions)
	3. App catches DB exception and maps it to clean error
Example:

catch (DataIntegrityViolationException e) {
    throw new DuplicateSkuException();
}

6ï¸âƒ£ Can validation replace constraint?
âŒ Never for uniqueness
Validation can replace:
	â€¢ NOT NULL
	â€¢ Length checks
	â€¢ Format checks (regex)
Validation CANNOT replace:
	â€¢ UNIQUE
	â€¢ PRIMARY KEY
	â€¢ FOREIGN KEY







*/